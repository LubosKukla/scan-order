<!-- generated by AI -->
<template>
  <Teleport to="body">
    <div class="fixed inset-x-0 bottom-6 z-[999] flex justify-end px-6 pointer-events-none">
      <transition-group
        v-if="orderedSnackbars.length"
        name="snackbar"
        tag="div"
        class="relative flex flex-col items-end pointer-events-none"
      >
        <article
          v-for="(snackbar, index) in orderedSnackbars"
          :key="snackbar.renderKey"
          class="snackbar-item pointer-events-auto rounded-3xl bg-white text-deep shadow-[0_12px_30px_rgba(15,23,42,0.2)] px-5 py-4 flex items-center gap-4 w-[min(360px,calc(100vw-2rem))]"
          :style="itemStyle(snackbar.id, index, orderedSnackbars.length)"
          @click="handleClick(snackbar.id)"
          @mouseenter="handleMouseEnter(snackbar.id)"
          @mouseleave="handleMouseLeave"
        >
          <span class="snackbar-icon inline-flex h-7 w-7 items-center justify-center rounded-full bg-deep text-white">
            <font-awesome-icon :icon="iconFor(snackbar.variant, snackbar.icon)" class="text-white" />
          </span>
          <p class="snackbar-message text-sm font-semibold text-deep">
            {{ snackbar.message }}
          </p>
        </article>
      </transition-group>
    </div>
  </Teleport>
</template>

<script>
import { computed, ref, onBeforeUnmount } from 'vue';
import { FontAwesomeIcon } from '@fortawesome/vue-fontawesome';
import { faCircleCheck, faCircleInfo, faTriangleExclamation, faCircleXmark } from '@fortawesome/free-solid-svg-icons';
import { useSnackbar } from '@/composables/useSnackbar';

const ICON_MAP = {
  success: faCircleCheck,
  default: faCircleCheck,
  info: faCircleInfo,
  warning: faTriangleExclamation,
  danger: faCircleXmark,
  check: faCircleCheck,
};

export default {
  name: 'SnackbarStack',
  components: {
    FontAwesomeIcon,
  },
  setup() {
    const { snackbars, dismiss, pauseAll, resumeAll } = useSnackbar();
    const orderedSnackbars = computed(() => [...snackbars].reverse());
    const hoveredId = ref(null);
    const hoverTimeout = ref(null);

    const itemStyle = (snackbarId, index, total) => {
      const hoveringAny = hoveredId.value !== null;
      const depthFromBottom = total - index - 1;
      const depth = Math.min(depthFromBottom, 4);
      const overlap = 20;
      const offset = depth * overlap;
      const translate = offset;
      const scale = Math.max(0.75, 1 - depth * 0.06);
      const opacity = 1 - depth * 0.12;
      const enterOffset = translate + 40;
      const leaveOffset = 0;
      const enterScale = Math.min(1, scale + 0.05);
      const leaveScale = 1;

      if (hoveringAny) {
        return {
          marginTop: index === 0 ? '0px' : '8px',
          zIndex: hoveredId.value === snackbarId ? 250 : 150 - index,
          transform: 'translateY(0px) scale(1)',
          opacity: 1,
          '--stack-enter-offset': '40px',
          '--stack-leave-offset': '0px',
          '--stack-enter-scale': '1',
          '--stack-leave-scale': '1',
        };
      }

      return {
        marginTop: index === 0 ? '0px' : `-${overlap * 0.4}px`,
        zIndex: 100 - depth,
        transform: `translateY(${translate}px) scale(${scale.toFixed(2)})`,
        opacity: opacity.toFixed(2),
        '--stack-enter-offset': `${enterOffset}px`,
        '--stack-leave-offset': `${leaveOffset}px`,
        '--stack-enter-scale': enterScale.toFixed(2),
        '--stack-leave-scale': leaveScale.toFixed(2),
      };
    };

    const handleClick = (id) => {
      dismiss(id);
    };

    const handleMouseEnter = (id) => {
      hoveredId.value = id;
      if (hoverTimeout.value) {
        clearTimeout(hoverTimeout.value);
        hoverTimeout.value = null;
      }
      pauseAll();
    };

    const handleMouseLeave = () => {
      if (hoverTimeout.value) {
        clearTimeout(hoverTimeout.value);
      }
      hoverTimeout.value = setTimeout(() => {
        hoveredId.value = null;
        resumeAll();
        hoverTimeout.value = null;
      }, 80);
    };

    onBeforeUnmount(() => {
      if (hoverTimeout.value) {
        clearTimeout(hoverTimeout.value);
      }
      resumeAll();
    });

    const iconFor = (variant, explicitIcon) => {
      if (explicitIcon && ICON_MAP[explicitIcon]) return ICON_MAP[explicitIcon];
      if (variant && ICON_MAP[variant]) return ICON_MAP[variant];
      return ICON_MAP.default;
    };

    return {
      orderedSnackbars,
      handleClick,
      handleMouseEnter,
      handleMouseLeave,
      itemStyle,
      iconFor,
    };
  },
};
</script>

<style scoped>
.snackbar-item {
  transition: transform 0.55s cubic-bezier(0.4, 0.14, 0.3, 1), opacity 0.6s ease, margin 0.25s ease;
  cursor: pointer;
}

.snackbar-icon {
  flex: none;
}

.snackbar-enter-from {
  opacity: 0;
  transform: translateY(var(--stack-enter-offset, 40px)) scale(var(--stack-enter-scale, 0.95));
}

.snackbar-leave-to {
  opacity: 0;
  transform: translateY(var(--stack-leave-offset, 0px)) scale(var(--stack-leave-scale, 1));
}

.snackbar-enter-active,
.snackbar-leave-active {
  transition: all 0.6s cubic-bezier(0.4, 0.14, 0.3, 1);
}

.snackbar-leave-active {
  position: absolute;
}

.snackbar-move {
  transition: transform 0.55s cubic-bezier(0.4, 0.14, 0.3, 1);
}
</style>
