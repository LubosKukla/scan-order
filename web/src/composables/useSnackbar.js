//generated by AI
import { reactive, readonly } from 'vue';

const DEFAULT_DURATION = 5000;
const stack = reactive([]);
const timers = new Map();

let seed = 0;
let renderSeed = 0;
let isPaused = false;

function nextRenderKey() {
  renderSeed += 1;
  return renderSeed;
}

function schedule(snackbar, overrideDuration) {
  const duration = typeof overrideDuration === 'number' ? overrideDuration : snackbar.duration || DEFAULT_DURATION;
  const existing = timers.get(snackbar.id);
  if (existing?.timeoutId) {
    clearTimeout(existing.timeoutId);
  }

  if (isPaused) {
    timers.set(snackbar.id, { timeoutId: null, remaining: duration });
    return;
  }

  const endTime = Date.now() + duration;
  const timeoutId = setTimeout(() => {
    timers.delete(snackbar.id);
    dismiss(snackbar.id);
  }, duration);
  timers.set(snackbar.id, { timeoutId, endTime, remaining: null });
}

function createPayload(messageOrPayload, maybeOptions) {
  if (typeof messageOrPayload === 'string') {
    return {
      message: messageOrPayload,
      ...maybeOptions,
    };
  }
  return { ...messageOrPayload };
}

const MAX_STACK = 4;

function notify(messageOrPayload, maybeOptions = {}) {
  const payload = createPayload(messageOrPayload, maybeOptions);
  const snackbar = {
    id: ++seed,
    message: payload.message || '',
    icon: payload.icon || null,
    variant: payload.variant || 'success',
    duration: typeof payload.duration === 'number' ? payload.duration : DEFAULT_DURATION,
    renderKey: nextRenderKey(),
  };

  if (stack.length >= MAX_STACK && stack[stack.length - 1]) {
    dismiss(stack[stack.length - 1].id);
  }
  stack.unshift(snackbar);
  schedule(snackbar, snackbar.duration);

  return snackbar.id;
}

function dismiss(id) {
  const index = stack.findIndex((snackbar) => snackbar.id === id);
  if (index === -1) return;

  stack.splice(index, 1);

  const timer = timers.get(id);
  if (timer?.timeoutId) {
    clearTimeout(timer.timeoutId);
  }
  timers.delete(id);
}

function promote(id) {
  const index = stack.findIndex((snackbar) => snackbar.id === id);
  if (index === -1) return;

  if (index === 0) {
    dismiss(id);
    return;
  }

  const [snackbar] = stack.splice(index, 1);
  snackbar.renderKey = nextRenderKey();
  stack.unshift(snackbar);
  schedule(snackbar, snackbar.duration);
}

function clearAll() {
  stack.splice(0, stack.length);
  timers.forEach((meta) => {
    if (meta?.timeoutId) {
      clearTimeout(meta.timeoutId);
    }
  });
  timers.clear();
}

function pauseAllTimers() {
  if (isPaused) return;
  isPaused = true;
  timers.forEach((meta, id) => {
    if (!meta) return;
    if (meta.timeoutId) {
      const remaining = Math.max(0, meta.endTime - Date.now());
      clearTimeout(meta.timeoutId);
      timers.set(id, { timeoutId: null, remaining });
    }
  });
}

function resumeAllTimers() {
  if (!isPaused) return;
  isPaused = false;
  timers.forEach((meta, id) => {
    const snackbar = stack.find((item) => item.id === id);
    if (!snackbar) {
      timers.delete(id);
      return;
    }
    const remaining = typeof meta?.remaining === 'number' ? meta.remaining : snackbar.duration || DEFAULT_DURATION;
    schedule(snackbar, remaining);
  });
}

export function useSnackbar() {
  return {
    snackbars: readonly(stack),
    notify,
    dismiss,
    promote,
    clearAll,
    pauseAll: pauseAllTimers,
    resumeAll: resumeAllTimers,
  };
}

export default useSnackbar;
